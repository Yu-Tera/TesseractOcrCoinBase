using System;
using System.IO;
using OpenCvSharp;
using Tesseract;
using System.Drawing;
using OpenCvSharp.Extensions;


using Rect = OpenCvSharp.Rect;
using CvPoint = OpenCvSharp.Point;


class Program
{
    static void Main()
    {
        string imageFolder = @"C:\Users\Yu-DESK\Videos\NVIDIA\Delta Force"; // ç”»åƒãƒ•ã‚©ãƒ«ãƒ€
        string tessdataPath = @"C:\Program Files\Tesseract-OCR\tessdata"; // tessdataã®ãƒ‘ã‚¹
        

        foreach (var file in Directory.GetFiles(imageFolder, "*.png"))
        {
            using var full = new Mat(file, ImreadModes.Color);

            // 1. å¤–æ ã‚’é™¤å»
            var cropRect = new Rect(425, 126, full.Width - 425 - 84, full.Height - 126 - 65);
            var cropped = new Mat(full, cropRect);

            // 2. æ¨ª3åˆ†å‰²
            int sliceWidth = cropped.Width / 3;
            for (int i = 0; i < 3; i++)
            {
                var sliceRect = new Rect(i * sliceWidth, 0, sliceWidth, cropped.Height);
                var slice = new Mat(cropped, sliceRect);

                // ğŸ”¸ ã“ã®sliceå†…ã§æ¤œå‡ºã•ã‚ŒãŸæ•°å­—é ˜åŸŸã‚’è¨˜éŒ²ã™ã‚‹ãƒªã‚¹ãƒˆ
                List<Rect> scannedNumberRegions = new List<Rect>();




                // 3. ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒãƒƒãƒãƒ³ã‚°ã§éŠ€è‰²ã‚³ã‚¤ãƒ³ã®ä½ç½®ã‚’æ¤œå‡º
                var gray = new Mat();
                Cv2.CvtColor(slice, gray, ColorConversionCodes.BGR2GRAY);
                
                string[] templateFiles = Directory.GetFiles("Templates", "coin_template_*.png");


                foreach (var templatePath in templateFiles)
                {
                    var itemplate = Cv2.ImRead(templatePath, ImreadModes.Grayscale);
                    if (itemplate.Empty()) continue;
                    if (itemplate.Width > slice.Width || itemplate.Height > slice.Height)
                    {
                        Console.WriteLine($"ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ {templatePath} ãŒã‚¹ãƒ©ã‚¤ã‚¹ã‚ˆã‚Šå¤§ãã„ãŸã‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚");
                        continue;
                    }

                    // ğŸ”¸ sliceã®å³åŠåˆ†ã ã‘ã‚’æ¤œç´¢å¯¾è±¡ã«ã™ã‚‹
                    var searchRegion = new Rect(slice.Width *3 / 4, 0, slice.Width / 4, slice.Height);
                    var searchMat = new Mat(slice, searchRegion);

                    // ğŸ”§ ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«åŒ–ï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã¨å½¢å¼ã‚’åˆã‚ã›ã‚‹ï¼‰
                    Cv2.CvtColor(searchMat, searchMat, ColorConversionCodes.BGR2GRAY);


                    var result = searchMat.MatchTemplate(itemplate, TemplateMatchModes.CCoeffNormed);

                    // ğŸ”¸ ä¸€è‡´åº¦ãŒé«˜ã„ä½ç½®ã‚’ã™ã¹ã¦æŠ½å‡º
                    List<CvPoint> matchPoints = new List<CvPoint>();
                    for (int y = 0; y < result.Rows; y++)
                    {
                        for (int x = 0; x < result.Cols; x++)
                        {
                            float score = result.At<float>(y, x);
                            if (score >= 0.6)
                            {
                                matchPoints.Add(new CvPoint(x, y));
                            }
                        }
                    }

                    // ğŸ”¸ è¿‘æ¥ç‚¹ã‚’ã¾ã¨ã‚ã‚‹ï¼ˆé‡è¤‡é™¤å»ï¼‰
                    List<CvPoint> filteredPoints = new List<CvPoint>();
                    int minDistance = 20;
                    foreach (var pt in matchPoints)
                    {
                        bool tooClose = filteredPoints.Any(p => Math.Abs(p.X - pt.X) < minDistance && Math.Abs(p.Y - pt.Y) < minDistance);
                        if (!tooClose)
                            filteredPoints.Add(pt);
                    }

                    // ğŸ”¸ æ¤œå‡ºæ¸ˆã¿é ˜åŸŸã‚’è¨˜éŒ²ã—ã¦ã‚¹ã‚­ãƒƒãƒ—
                    List<Rect> scannedRegions = new List<Rect>();

                    foreach (var loc in filteredPoints)
                    {
                        var absoluteLoc = new CvPoint(loc.X + searchRegion.X, loc.Y); // sliceåº§æ¨™ã«æˆ»ã™
                        var coinRect = new Rect(absoluteLoc.X, absoluteLoc.Y, itemplate.Width, itemplate.Height);

                        bool alreadyScanned = scannedRegions.Any(r => r.IntersectsWith(coinRect));
                        if (alreadyScanned)
                            continue;

                        scannedRegions.Add(coinRect);

                        // ğŸ”¸ æ•°å­—é ˜åŸŸï¼ˆã‚³ã‚¤ãƒ³ã®å³å´ï¼‰
                        var numberRect = new Rect(
                            coinRect.X + coinRect.Width,
                            coinRect.Y,
                            slice.Width - (coinRect.X + coinRect.Width),
                            30
                        );

                        if (numberRect.X < 0 || numberRect.Y < 0 || numberRect.X + numberRect.Width > slice.Width || numberRect.Y + numberRect.Height > slice.Height)
                            continue;

                        // ğŸ”¸ é‡è¤‡ãƒã‚§ãƒƒã‚¯
                        bool overlaps = scannedNumberRegions.Any(r => r.IntersectsWith(numberRect));
                        if (overlaps)
                            continue;

                        scannedNumberRegions.Add(numberRect);


                        string numberText = RunTesseractDigitsOnly(slice, numberRect, tessdataPath);

                        // æ•°å­—ãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆã®ã¿åå‰ã‚’æ¤œç´¢
                        if (!string.IsNullOrWhiteSpace(numberText) && numberText != "(ãªã—)" && numberText != "(ç©ºç”»åƒ)")
                        {
                            int nameY = coinRect.Y + 30 - 155;//ä¸Šä¸‹ä½ç½®
                            var nameRect = new Rect(0, nameY, 260, 30);
                            if (nameRect.X < 0 || nameRect.Y < 0 || nameRect.X + nameRect.Width > slice.Width || nameRect.Y + nameRect.Height > slice.Height)
                                continue;

                            string nameText = RunTesseract(slice, nameRect, tessdataPath);

                            Console.WriteLine($"æ•°å­—: {numberText}, åå‰: {nameText}");

                            Cv2.Rectangle(slice, coinRect, Scalar.Green, 2);
                            Cv2.Rectangle(slice, numberRect, Scalar.Red, 2);
                            Cv2.Rectangle(slice, nameRect, Scalar.Blue, 2);
                        }
                        else
                        {
                            

                            Cv2.Rectangle(slice, coinRect, Scalar.Green, 2);
                            Cv2.Rectangle(slice, numberRect, Scalar.Red, 2);
                        }
                    }

                    }

                    string debugPath = Path.Combine("DebugImages", $"slice_{DateTime.Now:yyyyMMdd_HHmmssfff}.png");
                Directory.CreateDirectory("DebugImages");
                slice.SaveImage(debugPath);
                Console.WriteLine($"æç”»ä»˜ãã‚¹ãƒ©ã‚¤ã‚¹ç”»åƒã‚’ä¿å­˜ã—ã¾ã—ãŸ: {debugPath}");

            }
        }
    }

    static string RunTesseract(Mat image, Rect roi, string tessdataPath)
    {
        

        // ROIï¼ˆæŒ‡å®šç¯„å›²ï¼‰ã‚’åˆ‡ã‚Šå‡ºã—
        
        var cropped = new Mat(image, roi);
        if (cropped.Empty())
        {
            Console.WriteLine("åˆ‡ã‚Šå‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆç©ºã®ç”»åƒï¼‰ã€‚");
            return "(ç©ºç”»åƒ)";
        }
        if (roi.X < 0 || roi.Y < 0 || roi.X + roi.Width > image.Width || roi.Y + roi.Height > image.Height)
        {
            Console.WriteLine($"ç„¡åŠ¹ãªROI: x={roi.X}, y={roi.Y}, width={roi.Width}, height={roi.Height}");
            return "(é ˜åŸŸå¤–)";
        }


        // ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«åŒ–ï¼‹äºŒå€¤åŒ–ï¼ˆOCRç²¾åº¦å‘ä¸Šï¼‰
        Cv2.CvtColor(cropped, cropped, ColorConversionCodes.BGR2GRAY);

        // ğŸ”¸ æ–‡å­—ã‚’èªè­˜ã™ã‚‹ãŸã‚æ‹¡å¤§
        Cv2.Resize(cropped, cropped, new OpenCvSharp.Size(cropped.Width * 2.8, cropped.Height * 2.8), interpolation: InterpolationFlags.Linear);


        Cv2.GaussianBlur(cropped, cropped, new OpenCvSharp.Size(3, 3), 0);

        Cv2.Threshold(cropped, cropped, 0, 255, ThresholdTypes.Otsu);

        // Mat â†’ Bitmap ã«å¤‰æ›
        using var bitmap = BitmapConverter.ToBitmap(cropped);

        // Bitmap â†’ MemoryStream â†’ byte[] â†’ Pix ã«å¤‰æ›
        using var ms = new MemoryStream();
        bitmap.Save(ms, System.Drawing.Imaging.ImageFormat.Png);
        ms.Position = 0;
        using var pix = Pix.LoadFromMemory(ms.ToArray());

        // OCRã‚¨ãƒ³ã‚¸ãƒ³ã§èª­ã¿å–ã‚Š
        using var engine = new TesseractEngine(tessdataPath, "jpn+eng", EngineMode.Default);
        using var page = engine.Process(pix);



        // çµæœã‚’è¿”ã™
        return string.IsNullOrWhiteSpace(page.GetText()) ? "(ãªã—)" : page.GetText().Trim();
    }


    static string RunTesseractDigitsOnly(Mat image, Rect roi, string tessdataPath)
    {
        if (roi.X < 0 || roi.Y < 0 || roi.X + roi.Width > image.Width || roi.Y + roi.Height > image.Height)
        {
            Console.WriteLine($"ç„¡åŠ¹ãªROI: x={roi.X}, y={roi.Y}, width={roi.Width}, height={roi.Height}");
            return "(é ˜åŸŸå¤–)";
        }

        var cropped = new Mat(image, roi);
        if (cropped.Empty())
        {
            Console.WriteLine("åˆ‡ã‚Šå‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆç©ºã®ç”»åƒï¼‰ã€‚");
            return "(ç©ºç”»åƒ)";
        }

        Cv2.CvtColor(cropped, cropped, ColorConversionCodes.BGR2GRAY);
        Cv2.GaussianBlur(cropped, cropped, new OpenCvSharp.Size(3, 3), 0);
        Cv2.Threshold(cropped, cropped, 0, 255, ThresholdTypes.Otsu);

        using var bitmap = BitmapConverter.ToBitmap(cropped);
        using var ms = new MemoryStream();
        bitmap.Save(ms, System.Drawing.Imaging.ImageFormat.Png);
        ms.Position = 0;
        using var pix = Pix.LoadFromMemory(ms.ToArray());

        using var engine = new TesseractEngine(tessdataPath, "eng", EngineMode.Default);
        engine.SetVariable("tessedit_char_whitelist", "0123456789,"); // ğŸ”¸ æ•°å­—ã¨ã‚³ãƒ³ãƒã ã‘è¨±å¯
        using var page = engine.Process(pix);

        return string.IsNullOrWhiteSpace(page.GetText()) ? "(ãªã—)" : page.GetText().Trim();
    }

}